Public Function GroupCodesInSet(strScheme As String, strCodeField As String, strTableName As String, Optional strGroprintlogupField As String, Optional ClusterID As String, Optional ClusterVersion As String = "", _
                                Optional TargetClauseCount As Integer = 1, Optional WithExclusions As Boolean = True, Optional strStickyExclusions As String = "", Optional strStickyInclusions As String = "", Optional FrequencyWeighted As Boolean = False, _
                                Optional CompressionStrategy As Byte = 1, Optional ApplyFilters As Boolean = False, Optional TargetSchemeReleaseDateFilter As String = "", Optional ClauseSyntax As String = "SIMPLE") As String
                                
    Dim TempDB As DAO.Database, myWinner As DAO.Recordset, strAllowlistExclusions As String, AllowListExclusions As New CLUSTER, StickyExclusions As New CLUSTER, StickyInclusions As New CLUSTER, myClause As New Clause
    Dim res As Boolean, strDataType As String, strSQL As String, strHIER As String, strTC As String, Winner As String, strWinner As String, xWinner As String, IncludeWinner As Boolean, NeedsExclusions As Boolean
    Dim ListSize As Long, ListCoverage As Long, xListSize As Long, FullListSize As Long, PartialListSize As Long, strRule As String, TotalFrequency As Long, str As String
    Dim ClauseCount As Integer, IdealClauseCount As Integer, Zoom As Integer, MaxClauseCount As Integer, ClauseCountWeighting As Integer, MinimumClusterSize As Integer
    Dim MinimumFitThreshold As Double, FitThreshold As Double, NewFitThreshold As Double, i As Long
    Dim WinnerExistsAtCurrentZoom As Boolean, ClauseNumber As Long, Iteration As Integer, Residue As Long, ClauseCoverage As Long
    Dim xZoom As Integer, xIteration As Integer, xTerminateNow As Boolean, xForceTerminationTime As Date
    Dim MaxIterations As Integer, MaxElapsedTimeHours As Double, MaxCoverage As Integer, ForceTerminationTime As Date, TerminateNow As Boolean, initLogLevel As Byte
    
    DoCmd.Hourglass True
    GroupCodesInSet = ""
    initLogLevel = LogLevel
    CancelCurrentOperation = False
    
    'Compression Strategies:
    '1 = default, lossless (membership list is the same after refactoring as before)
    '2 = loose, lossless (membership list is the same after refactoring as before)
    '3 = looser, lossless (membership list is the same after refactoring as before)
    '4 = Fuzzy compression (membership list after refactoring is different)
    
    If Not SchemeIsSupported(strScheme) Then
        PrintLog "ERROR: " & strScheme & " was not found on your system"
        GroupCodesInSet = ""
        Exit Function
    End If
    
    'Collate any sticky clauses present in the source member enumeration table
    strSQL = "SELECT DISTINCT INCLUDE,EXTENSION, " & strCodeField & " AS CUI " _
           & "FROM " & strTableName & " WHERE LEFT(EXTENSION,1) = '@' " & IIf(ClusterID <> "", " AND " & strGroupField & " = '" & ClusterID & "' ", " ") _
           & "AND " & strCodeField & " <> '' AND NOT ISNULL(" & strCodeField & ")" & IIf(ClusterVersion <> "", " AND VERSION = '" & ClusterVersion & "'", "") & ";"
    Set myWinner = MyDB.OpenRecordset(strSQL)
    If Not (myWinner.BOF And myWinner.EOF) Then
        myWinner.MoveFirst
        Do Until myWinner.EOF
            strWinner = myWinner!CUI
            Select Case Right(myWinner!extension, 1)
                Case Is = "%"
                    strWinner = "@<<" & strWinner
                Case Is = "+"
                    strWinner = "@<" & strWinner
                Case Is = "="
                    strWinner = "@=" & strWinner
                Case Is = "!"
                    strWinner = "@:<" & strWinner
                Case Is = "�"
                    strWinner = "@:=" & strWinner
            End Select
            Select Case myWinner!include
                Case True
                    strStickyInclusions = strStickyInclusions & IIf(strStickyInclusions = "", "", "|") & strWinner
                Case False
                    strStickyExclusions = strStickyExclusions & IIf(strStickyExclusions = "", "", "|") & strWinner
            End Select
            myWinner.MoveNext
        Loop
    End If
    myWinner.Close
    Set StickyExclusions = New CLUSTER
    StickyExclusions.Scheme = strScheme
    StickyExclusions.add strStickyExclusions
            
    Set StickyInclusions = New CLUSTER
    StickyInclusions.Scheme = strScheme
    StickyInclusions.add strStickyInclusions
    
    'Collate any allowlist exclusion clauses present in the source member enumeration table
    strSQL = "SELECT DISTINCT INCLUDE,EXTENSION, " & strCodeField & " AS CUI " _
           & "FROM " & strTableName & " WHERE LEFT(EXTENSION,1) = '" & allowlistedConceptMarker & "' " & IIf(ClusterID <> "", " AND " & strGroupField & " = '" & ClusterID & "' ", " ") _
           & "AND " & strCodeField & " <> '' AND NOT ISNULL(" & strCodeField & ")" & IIf(ClusterVersion <> "", " AND VERSION = '" & ClusterVersion & "'", "") & ";"
    Set myWinner = MyDB.OpenRecordset(strSQL)
    If Not (myWinner.BOF And myWinner.EOF) Then
        myWinner.MoveFirst
        Do Until myWinner.EOF
            strWinner = myWinner!CUI
            Select Case Right(myWinner!extension, 1)
                Case Is = "%"
                    strWinner = "<<" & strWinner
                Case Is = "+"
                    strWinner = "<" & strWinner
                Case Is = "="
                    strWinner = "=" & strWinner
                Case Is = "!"
                    strWinner = ":<" & strWinner
                Case Is = "�"
                    strWinner = ":=" & strWinner
            End Select
            strAllowlistExclusions = strAllowlistExclusions & IIf(strAllowlistExclusions = "", "", "|") & strWinner
            myWinner.MoveNext
        Loop
    End If
    myWinner.Close
    Set AllowListExclusions = New CLUSTER
    AllowListExclusions.Scheme = strScheme
    AllowListExclusions.add strAllowlistExclusions

    'Determine datatype in working tables for codes to be refactored
    strDataType = CUIDatatypeForScheme(strScheme)

    'Create and/or clear the working tables in the Temp database
    On Error Resume Next
        MyDB.TableDefs.Delete "greedy_list"
        MyDB.TableDefs.Delete "greedy_list_x"
        MyDB.TableDefs.Delete "greedy_list_f"
        MyDB.TableDefs.Delete "greedy_exclusion_list"
        MyDB.TableDefs.Delete "greedy_temp"
        MyDB.TableDefs.Delete "greedy_int"
        MyDB.TableDefs.Delete "greedy_vals"
        MyDB.TableDefs.Delete "greedy_vals_x"
        MyDB.TableDefs.Delete "greedy_ancestors"
        MyDB.TableDefs.Delete "greedy_ancestors_x"
        MyDB.TableDefs.Delete "greedy_ancestors_metrics"
        MyDB.TableDefs.Delete "greedy_tc"
        MyDB.TableDefs.Delete "greedy_tc_x"
        MyDB.TableDefs.Delete "query_refactored"
        If Not KillFile(tPath, "Temp.mdb") Then PrintLog ("ERROR: Could not delete working table before REFACTOR")
        DBEngine.CreateDatabase tPath & "Temp.mdb", dbLangGeneral, dbVersion40
        Set TempDB = OpenDatabase(tPath & "Temp.mdb")
        TempDB.Execute "CREATE TABLE greedy_list (CUI " & strDataType & " NOT NULL, ID VARCHAR(30)" & IIf(FrequencyWeighted = True, ", FREQ DOUBLE", "") & ");"
        TempDB.Execute "CREATE TABLE greedy_list_x (CUI " & strDataType & " NOT NULL, ID VARCHAR(30));"
        TempDB.Execute "CREATE TABLE greedy_list_f (CUI " & strDataType & " NOT NULL, ID VARCHAR(30)" & IIf(FrequencyWeighted = True, ", FREQ DOUBLE", "") & ");"
        TempDB.Execute "CREATE TABLE greedy_exclusion_list (CUI " & strDataType & " NOT NULL, ID VARCHAR(30));"
        TempDB.Execute "CREATE TABLE greedy_temp (CUI " & strDataType & " NOT NULL);"
        TempDB.Execute "CREATE TABLE greedy_int (CUI " & strDataType & " NOT NULL, NUM DOUBLE NOT NULL" & IIf(FrequencyWeighted = True, ", FREQ DOUBLE", "") & ");"
        TempDB.Execute "CREATE INDEX cui_x ON greedy_int(CUI);"
        TempDB.Execute "CREATE INDEX cui_x ON greedy_list(CUI);"
        TempDB.Execute "CREATE INDEX cui_x ON greedy_list_f(CUI);"
        TempDB.Execute "CREATE TABLE greedy_vals (CUI " & strDataType & " NOT NULL, INCLUDE BIT, ALLCUI DOUBLE, TRUEPOS DOUBLE, TRUENEG DOUBLE " & IIf(FrequencyWeighted = True, ", FREQ DOUBLE", " ") & ", SCORE DOUBLE);"
        TempDB.Execute "CREATE TABLE greedy_vals_x (CUI " & strDataType & " NOT NULL, INCLUDE BIT, ALLCUI DOUBLE, TRUEPOS DOUBLE, TRUENEG DOUBLE, SCORE DOUBLE);"
        TempDB.Execute "CREATE TABLE greedy_ancestors (CUI " & strDataType & " NOT NULL, INCLUDE BIT, ALLDESCENDENTS DOUBLE, TRUEPOS DOUBLE, TRUENEG DOUBLE, ALLCHILDREN DOUBLE, TRUECHILDREN DOUBLE" & IIf(FrequencyWeighted = True, ", FREQ DOUBLE", " ") & ", SCORE DOUBLE);"
        TempDB.Execute "CREATE TABLE greedy_ancestors_x (CUI " & strDataType & " NOT NULL, INCLUDE BIT, ALLDESCENDENTS DOUBLE, TRUEPOS DOUBLE, TRUENEG DOUBLE, ALLCHILDREN DOUBLE, TRUECHILDREN DOUBLE, SCORE DOUBLE);"
        TempDB.Execute "CREATE TABLE greedy_ancestors_metrics (CUI " & strDataType & " NOT NULL, ALLDESCENDENTS DOUBLE, ALLCHILDREN DOUBLE, TRUECHILDREN DOUBLE);"
        TempDB.Execute "DROP INDEX cui_x ON greedy_ancestors_metrics;"
        TempDB.Execute "CREATE TABLE greedy_tc (SUPERTYPEID " & strDataType & " NOT NULL, SUBTYPEID " & strDataType & " NOT NULL)"
        TempDB.Execute "CREATE TABLE greedy_tc_x (SUPERTYPEID " & strDataType & " NOT NULL, SUBTYPEID " & strDataType & " NOT NULL)"
        TempDB.Execute "DROP TABLE QUERY_REFACTORED;"
        TempDB.Execute "CREATE TABLE QUERY_REFACTORED (ID VARCHAR(30), CLAUSENUM INT, SCORE DOUBLE, STICKY BIT, INCLUDE BIT, EXTENSION VARCHAR(2) NOT NULL, CUI " & strDataType & " NOT NULL, DESCENDENTS DOUBLE, TRUEPOS DOUBLE, TRUENEG DOUBLE, ALLCHILDREN DOUBLE, TRUECHILDREN DOUBLE, ZOOM DOUBLE, LISTSIZE DOUBLE)"
        TempDB.Execute "CREATE INDEX id_x ON Query_Refactored(CUI);"
        TempDB.Execute "DELETE FROM QUERY_REFACTORED;"
        TempDB.Execute "DELETE FROM greedy_list;"
        TempDB.Execute "DELETE FROM greedy_list_f;"
        TempDB.Execute "DELETE FROM greedy_list_x;"
        TempDB.Execute "DELETE FROM greedy_exclusion_list;"
        TempDB.Execute "DELETE FROM greedy_temp;"
        TempDB.Execute "DELETE FROM greedy_int;"
        TempDB.Execute "DELETE FROM greedy_vals;"
        TempDB.Execute "DELETE FROM greedy_vals_x;"
        TempDB.Execute "DELETE FROM greedy_ancestors;"
        TempDB.Execute "DELETE FROM greedy_ancestors_x;"
        TempDB.Execute "DELETE FROM greedy_ancestors_metrics;"
        TempDB.Execute "DELETE FROM greedy_tc;"
        TempDB.Execute "DELETE FROM greedy_tc_x;"
        TempDB.Execute "DROP INDEX sb_x ON greedy_tc;"
        TempDB.Execute "DROP INDEX sp_x ON greedy_tc;"
        TempDB.Execute "DROP INDEX c_x ON greedy_vals;"
        TempDB.Execute "DROP INDEX c_x ON greedy_ancestors;"
        TempDB.Execute "DROP INDEX id_x ON greedy_temp;"
        TempDB.Execute "DROP INDEX c_x ON greedy_exclusion_list;"
        TempDB.Execute "DROP INDEX c_x ON greedy_list_x;"
        TempDB.Execute "DROP INDEX sb_x ON greedy_tc_x;"
        TempDB.Execute "DROP INDEX sp_x ON greedy_tc_x;"
        TempDB.Execute "DROP INDEX c_x ON greedy_vals_x;"
        TempDB.Execute "DROP INDEX c_x ON greedy_ancestors_x;"
    On Error GoTo GroupCodesInSet_Error

    res = Relink("QUERY_REFACTORED", "Temp.mdb")
    If res Then res = Relink("greedy_list", "Temp.mdb")
    If res Then res = Relink("greedy_list_f", "Temp.mdb")
    If res Then res = Relink("greedy_tc", "Temp.mdb")
    If res Then res = Relink("greedy_tc_x", "Temp.mdb")
    If res Then res = Relink("greedy_temp", "Temp.mdb")
    If res Then res = Relink("greedy_vals", "Temp.mdb")
    If res Then res = Relink("greedy_ancestors", "Temp.mdb")
    If res Then res = Relink("greedy_exclusion_list", "Temp.mdb")
    If res Then res = Relink("greedy_list_x", "Temp.mdb")
    If res Then res = Relink("greedy_vals_x", "Temp.mdb")
    If res Then res = Relink("greedy_ancestors_x", "Temp.mdb")
    If res Then res = Relink("greedy_ancestors_metrics", "Temp.mdb")

    If Not res Then
        PrintLog ("ERROR: REFACTOR couldn't make working tables. Can not proceed.")
        DoCmd.Hourglass False
        GroupCodesInSet = ""
        On Error Resume Next
        MyDB.TableDefs.Delete "greedy_list"
        MyDB.TableDefs.Delete "greedy_list_x"
        MyDB.TableDefs.Delete "greedy_list_f"
        MyDB.TableDefs.Delete "greedy_exclusion_list"
        MyDB.TableDefs.Delete "greedy_temp"
        MyDB.TableDefs.Delete "greedy_int"
        MyDB.TableDefs.Delete "greedy_vals"
        MyDB.TableDefs.Delete "greedy_vals_x"
        MyDB.TableDefs.Delete "greedy_ancestors"
        MyDB.TableDefs.Delete "greedy_ancestors_x"
        MyDB.TableDefs.Delete "greedy_ancestors_metrics"
        MyDB.TableDefs.Delete "greedy_tc"
        MyDB.TableDefs.Delete "greedy_tc_x"
        MyDB.TableDefs.Delete "query_refactored"
        Kill (tPath & "Temp.mdb")
        Exit Function
    End If
    
    'Pull the list of included codes in one cluster into the working area..
    strSQL = "INSERT INTO greedy_list_f SELECT DISTINCT " & strCodeField & " AS CUI, " & IIf(strGroupField <> "", strGroupField, "''") & " AS ID" & IIf(FrequencyWeighted = True, ", FREQ AS FREQ ", " ") _
               & "FROM " & strTableName & " WHERE EXTENSION = '=' AND INCLUDE = TRUE" & IIf(ClusterID <> "", " AND " & strGroupField & " = '" & ClusterID & "' ", " ") _
               & "AND " & strCodeField & " <> '' AND NOT ISNULL(" & strCodeField & ")" & IIf(ClusterVersion <> "", " AND VERSION = '" & ClusterVersion & "'", "") & ";"
    MyDB.Execute strSQL
    
    '..and then delete all explicitly excluded codes
    If ApplyFilters = True And strScheme = "SCT" Then
        'except, if the option to assume application of the SNOMED exclusion subset is selected in the cluster metadata,
        'then don't remove any concept already also covered by that subset
        '(memberhip of the exclusion subset is flagged by the F4 metadata flag on each SNOMED CT concept)
        'NB The ISNULL(s.F4) element of the SQL ensures that allowlisted content is always excluded
        MyDB.Execute "DELETE l.* FROM (greedy_list_f AS l INNER JOIN " & strTableName & " AS x ON l.CUI = x." & strCodeField & ")" _
                              & " LEFT JOIN SCT s ON s.CUI = l.CUI WHERE x.EXTENSION = '=' AND x.INCLUDE = FALSE AND (ISNULL(s.F4) OR (s.TYP = 1 AND s.F4 = FALSE)) " _
                              & IIf(ClusterID <> "", " AND x." & strGroupField & " = '" & ClusterID & "' ", " ") & IIf(ClusterVersion <> "", " AND VERSION = '" & ClusterVersion & "'", "") & ";"
    Else
        MyDB.Execute "DELETE l.* FROM greedy_list_f AS l INNER JOIN " & strTableName & " AS x ON l.CUI = x." & strCodeField & " WHERE x.EXTENSION = '=' AND x.INCLUDE = FALSE" _
                              & IIf(ClusterID <> "", " AND x." & strGroupField & " = '" & ClusterID & "' ", " ") & IIf(ClusterVersion <> "", " AND VERSION = '" & ClusterVersion & "'", "") & ";"
    End If
    
    TempDB.Execute "INSERT INTO greedy_list SELECT DISTINCT * FROM greedy_list_f;"
    '...so that the working area table (greedy_list) now contains the enumerated extensional code list for whom an intensional definition is to be generated
    
    'Initial scoring and weighting function parameters
    FullListSize = SQLCount("SELECT COUNT(CUI) AS Res FROM greedy_List WHERE ID = '" & ClusterID & "';", TempDB)
    ClauseCountWeighting = 1                    'Weighting function fudge factor. Exaggerates the influence of the IdealClauseCount. Effectively not used when value=1
    MinimumClusterSize = 2                      'No point having value less than 2. Not clear whether or when larger values would be useful.
    TotalFrequency = 1                          'Default value to prevent divide by zero error
    NeedsExclusions = False                     'Flag set true if there any exclusion clauses required
    
    If FrequencyWeighted = True Then
        TotalFrequency = SQLCount("SELECT SUM(FREQ) AS Res FROM greedy_list_f;")
        WithExclusions = False
        MaxCoverage = 80                         'Maximum % of total EPR content to attempt to group
        If TargetClauseCount > MaxCoverage Then MaxCoverage = TargetClauseCount
        If MaxCoverage > 100 Then MaxCoverage = 100
        MaxClauseCount = 1000                    'Cap the output to n clauses
        IdealClauseCount = TargetClauseCount     'use arg passed in call; assume lots of clauses are desired, but not too many
        FitThreshold = 0.9                       'Aim initially for clauses with a near perfect match to the target size
        MinimumFitThreshold = 0.005              'permit a much lower fit threshold than for the non-frequency weighted processing
    Else
        MaxClauseCount = 300                     'Cap the output to n clauses
        IdealClauseCount = 1                     'default setting goes for broke: aim initially for a single clause
        FitThreshold = 0.9                       'Aim initially for clauses with a near perfect fit (10% exclusions)
        MinimumFitThreshold = 0.5
        If TargetClauseCount > MaxClauseCount Then MaxClauseCount = TargetClauseCount
    End If
    
    PrintLog ("START: REFACTORING " & strScheme & " encoding of " & ClusterID & " : " & FullListSize & " code" & IIf(FullListSize = 1, "", "s") & " in full enumeration of cluster")
    If DebugOn Then
        If FrequencyWeighted = False Then
            PrintLog ("GOAL : " & IdealClauseCount & " clause" & IIf(IdealClauseCount = 1, "", "s") & " (and ideally <" & MaxClauseCount & ") with codes per clause = " & Round(FullListSize / IdealClauseCount, 0) & " (and don't group < " & MinimumClusterSize & ")")
        Else
            PrintLog ("GOAL : " & IdealClauseCount & " clause" & IIf(IdealClauseCount = 1, "", "s") & " (<" & MaxClauseCount & ") covering " & MaxCoverage & "% of EPR episodes (>" & MinimumClusterSize & " codes per clause)")
        End If
    End If
    LogLevel = LogLevel + 1
    
'    Select Case strScheme
'        Case "RCT", "CTV3", "SCT"
'            If DebugOn Then PrintLog ("START: Batch injection of allowlisted inclusions")
'                MyDB.Execute "INSERT INTO QUERY_REFACTORED SELECT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, 1 AS SCORE, FALSE AS STICKY, TRUE AS INCLUDE, " _
'                         & "'<<' AS EXTENSION, l.CUI AS CUI, 0 AS DESCENDENTS,1 AS TRUEPOS,0 AS TRUENEG,0 AS ZOOM, 0 AS LISTSIZE " _
'                         & "FROM greedy_list l INNER JOIN ALLOWLIST_" & IIf(strScheme = "CTV3", "RCT", strScheme) & " w ON l.CUI = w.CUI;"
'                ClauseNumber = ClauseNumber + MyDB.RecordsAffected
'                MyDB.Execute "DELETE l.* FROM greedy_list l INNER JOIN ALLOWLIST_" & IIf(strScheme = "CTV3", "RCT", strScheme) & " w ON l.CUI = w.CUI;"
'                If DubugOn Then PrintLog MyDB.RecordsAffected & " allowlists inclusion concept" & IIf(MyDB.RecordsAffected = 1, "", "s") & " added to refactored cluster definition"
'            If DebugOn Then PrintLog ("DONE: Batch injection of allowlisted inclusions")
'    End SelectListSize
    
    If StickyInclusions.ClauseCount > 0 Then
        If DebugOn Then PrintLog ("START: Inject sticky inclusion clauses")
        On Error Resume Next
        TempDB.Execute "DROP INDEX id_x ON greedy_temp;"
        TempDB.Execute "DELETE FROM greedy_temp;"
        On Error GoTo GroupCodesInSet_Error
        str = ""
        For i = 1 To StickyInclusions.ClauseCount
            Set myClause = New Clause
            xWinner = StickyInclusions.Clause(i, myClause) 'get next clause into myClause
            strRule = myClause.extension
            xWinner = myClause.CUI
            If InStr(str, strRule & xWinner) = 0 Then   'do not add same sticky clause more than once
                str = str & strRule & xWinner & "|" ' keep track of the sticky clauses added so far

                If SQLCount("SELECT COUNT(ID) AS RES FROM QUERY_REFACTORED WHERE ID = '" & ClusterID & "' AND INCLUDE = TRUE AND EXTENSION = '" & strRule & "' AND CUI = '" & xWinner & "';", MyDB) = 0 Then
                    PrintLog ("@" & strRule & DisplayCode(xWinner, strScheme))
                Else
                    PrintLog ("@" & strRule & DisplayCode(xWinner, strScheme) & " REDUNDANT")
                End If
                MyDB.Execute "INSERT INTO QUERY_REFACTORED SELECT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, 0 AS SCORE, TRUE AS STICKY, TRUE AS INCLUDE, " _
                             & "'" & strRule & "' AS EXTENSION, '" & xWinner & "' AS CUI,0 AS DESCENDENTS,0 AS TRUEPOS,0 AS TRUENEG,0 AS ZOOM, 0 AS LISTSIZE;"
                
                'Pull ALL concepts implied by the sticky inclusion clause from the FULL transitive closure table for the scheme
                Select Case strRule
                    Case Is = "="
                        strSQL = "INSERT INTO greedy_temp SELECT '" & xWinner & "' AS CUI;"
                    Case Is = "<"
                        strSQL = "INSERT INTO greedy_temp SELECT tc.SUBTYPEID AS CUI FROM " & strScheme & "TC tc WHERE tc.SUPERTYPEID = '" & xWinner & "' AND SUBTYPEID <> SUPERTYPEID"
                    Case Is = "<<"
                        strSQL = "INSERT INTO greedy_temp SELECT tc.SUBTYPEID AS CUI FROM " & strScheme & "TC tc WHERE tc.SUPERTYPEID = '" & xWinner & "';"
                    Case Is = ":<"
                        ClauseSyntax = "EXTENDED"
                        strSQL = "INSERT INTO greedy_temp SELECT r.CUI AS CUI FROM (SCTTC tc INNER JOIN SCTREL r ON (tc.SUPERTYPEID = '" & xWinner & "' AND tc.SUBTYPEID = r.CUI2)) INNER JOIN SCTMODREL a ON (r.REL = a.REL AND a.ALLOWED = TRUE);"
                    Case Is = ":="
                        ClauseSyntax = "EXTENDED"
                        strSQL = "INSERT INTO greedy_temp SELECT r.CUI AS CUI FROM SCTREL r INNER JOIN SCTMODREL a ON (r.REL = a.REL AND a.ALLOWED = TRUE) WHERE r.CUI2 = '" & xWinner & "';"
                End Select
                MyDB.Execute strSQL
                
                ClauseNumber = ClauseNumber + 1
                ClauseCount = ClauseCount + 1
            End If
        Next i
        
        'Remove all members of the set that are covered by the sticky inclusion clauses
        TempDB.Execute "CREATE INDEX id_x ON greedy_temp(CUI);"
        TempDB.Execute "DELETE l.* FROM greedy_list l INNER JOIN greedy_temp t ON t.CUI = l.CUI;"
        'Add to the exclusion set all those descendants of the sticky inclusion clauses that are NOT also in the full enumeration of the original cluster
        TempDB.Execute "INSERT INTO greedy_exclusion_list SELECT DISTINCT x.CUI AS CUI, '" & ClusterID & "' AS ID FROM greedy_temp x LEFT JOIN greedy_list_f l ON x.CUI = l.CUI WHERE ISNULL(l.CUI);"
        If TempDB.RecordsAffected > 0 Then NeedsExclusions = True
        If (NeedsExclusions = True And WithExclusions = False) Then
            WithExclusions = True
            PrintLog "ERROR: the sticky inclusion clauses in this cluster need exclusion clauses; ignoring request to refactor WITHOUT exclusion clauses"
            MsgBox "This cluster can not be refactored without using any exclusion clauses." & vbCrLf & "The sticky inclusion clauses MUST have exclusion clauses" & vbCrLf & "or the cluster memberlist would be different after refactoring" & vbCrLf & vbCrLf & "I shall produce a refactoring that DOES include exclusion clauses", vbCritical, "Refactoring problem"
        End If
        If DebugOn Then PrintLog ("DONE: Inject sticky inclusion clauses")
    End If
    
    If FrequencyWeighted = False And strScheme = "SCT" And ClauseSyntax = "EXTENDED" Then
        If DebugOn Then PrintLog ("START: Look for modelled value clauses")
        If DebugOn Then PrintLog ("Collating unique values for all modelled relationships in SNOMED CT")
        MyDB.Execute "INSERT INTO greedy_vals SELECT r.CUI2 AS CUI, COUNT(CUI) AS TRUEPOS FROM greedy_list l INNER JOIN (SCTREL r INNER JOIN SCTMODREL a ON (r.REL = a.REL AND a.ALLOWED = TRUE)) ON l.CUI = r.CUI " & IIf(ClusterID <> "", " WHERE l.ID = '" & ClusterID & "'", "") & " GROUP BY r.CUI2;"
        TempDB.Execute "CREATE INDEX c_x ON greedy_vals(CUI);"

        MyDB.Execute "INSERT INTO greedy_vals_x SELECT r.CUI2 AS CUI, COUNT(r.CUI) AS TRUEPOS FROM greedy_vals l INNER JOIN (SCTREL r INNER JOIN SCTMODREL a ON (r.REL = a.REL AND a.ALLOWED = TRUE)) ON l.CUI = r.CUI2 GROUP BY r.CUI2;"
        TempDB.Execute "CREATE INDEX c_x ON greedy_vals_x(CUI);"
        TempDB.Execute "UPDATE greedy_vals v INNER JOIN greedy_vals_x x ON v.CUI = x.CUI SET v.ALLCUI = x.TRUEPOS, v.TRUENEG = x.TRUEPOS - v.TRUEPOS, v.SCORE = (v.TRUEPOS/x.TRUEPOS);"
        TempDB.Execute "DROP INDEX c_x ON greedy_vals_x;"
        TempDB.Execute "DELETE FROM greedy_vals_x;"
        TempDB.Execute "DELETE FROM greedy_vals WHERE SCORE < 0.95 "
        TempDB.Execute "DELETE FROM greedy_vals WHERE TRUEPOS < 10 OR TRUENEG > 2"
        If SQLCount("SELECT COUNT(CUI) AS RES FROM greedy_vals;") > 0 Then
            'Accept as a batch all surviving modelled values
            strSQL = "SELECT CUI as strRes, TRUEPOS, SCORE FROM greedy_vals;"
            Set myWinner = TempDB.OpenRecordset(strSQL)
            If Not (myWinner.BOF And myWinner.EOF) Then
                If DebugOn Then PrintLog ("START: Modelled value clauses")
                myWinner.MoveFirst
                Do Until myWinner.EOF
                    Winner = myWinner!strRes
                    If DebugOn Then
                        strWinner = "Found Modelled Value Inclusion #" & ClauseNumber & " "
                        strWinner = strWinner & ":=" & DisplayCode(Winner, strScheme, , , True)
                        PrintLog strWinner
                    End If
                    'Post the winner into the output table
                    'Greedy Output : CLUSTERID CLAUSENUM SCORE INCLUDE EXTENSION CUI DESCENDENTS TRUEPOS TRUENEG ZOOM LISTSIZE
                    MyDB.Execute "INSERT INTO Query_Refactored SELECT DISTINCT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, SCORE AS SCORE, TRUE AS INCLUDE, " _
                               & "':=' AS EXTENSION, '" & Winner & "' AS CUI, ALLCUI AS DESCENDENTS, TRUEPOS AS TRUEPOS, TRUENEG AS TRUENEG, " _
                               & Zoom & " AS ZOOM, " & FullListSize & " AS LISTSIZE FROM greedy_vals a WHERE a.CUI = '" & Winner & "';"
                    
                    ClauseNumber = ClauseNumber + 1
                    ClauseCount = ClauseCount + 1
                    myWinner.MoveNext
                Loop
                myWinner.Close
                'Remove all codes covered by the new clauses from the code set to be considered in subsequent iterations
                MyDB.Execute "DELETE l.* FROM greedy_list l INNER JOIN (SCTREL r INNER JOIN greedy_vals v ON r.CUI2 = v.CUI) ON l.CUI = r.CUI;"
                
                'Remove any candidate ancestors if they don't have any descendents that are not already covered by the sticky inclusions
                MyDB.Execute "DELETE a.* FROM greedy_ancestors a LEFT JOIN (SELECT tc.SUPERTYPEID AS SUP FROM greedy_tc tc INNER JOIN greedy_list l ON l.CUI = tc.SUBTYPEID) x ON x.SUP = a.CUI WHERE ISNULL(x.SUP);"
                
                'Add to the exclusion set all those descendants of the modelled  inclusion clauses that are NOT also in the full enumeration of the original cluster
                MyDB.Execute "INSERT INTO greedy_exclusion_list SELECT DISTINCT r.CUI AS CUI, '" & ClusterID & "' AS ID FROM (SCTREL r INNER JOIN greedy_vals v ON v.CUI = r.CUI2) LEFT JOIN greedy_list_f l ON r.CUI = l.CUI WHERE ISNULL(l.CUI);"
                If MyDB.RecordsAffected > 0 Then NeedsExclusions = True
                If (NeedsExclusions = True And WithExclusions = False) Then
                    WithExclusions = True
                    PrintLog "ERROR: the modelled value clauses in this cluster need exclusion clauses; ignoring request to refactor WITHOUT exclusion clauses"
                    MsgBox "This cluster can not be refactored without using any exclusion clauses." & vbCrLf & "The modelled value clauses MUST have exclusion clauses" & vbCrLf & "or the cluster memberlist would be different after refactoring" & vbCrLf & vbCrLf & "I shall produce a refactoring that DOES include exclusion clauses", vbCritical, "Refactoring problem"
                End If
                If DebugOn Then PrintLog ("DONE: Modelled value clauses")
            End If
        End If
        TempDB.Execute "DELETE FROM greedy_vals;"
        TempDB.Execute "DROP INDEX c_x ON greedy_vals;"
        If DebugOn Then PrintLog ("START: Look for modelled relationship clauses")
    End If
    
    If DebugOn Then PrintLog ("Pulling relevant fragment of " & strScheme & "TC table")
    
    'Extract from the full transitive closure table only those rows relating to concepts that are an ancestor of ANY code EVER in the enmumerated cluster set
    If DebugOn Then PrintLog ("Extracting fragment of full transitive closure table")
    MyDB.Execute "INSERT INTO greedy_tc SELECT tc.SUPERTYPEID, tc.SUBTYPEID FROM " & strScheme & "TC tc INNER JOIN greedy_list_f l ON l.CUI = tc.SUBTYPEID" & IIf(ClusterID <> "", " WHERE l.ID = '" & ClusterID & "';", ";")
    TempDB.Execute "CREATE INDEX sb_x ON greedy_tc(SUBTYPEID);"
    TempDB.Execute "CREATE INDEX sp_x ON greedy_tc(SUPERTYPEID);"
    
    'Then identify the list of unique ancestors
    If DebugOn Then PrintLog ("Collating list of all unique candidate supertypes")
    TempDB.Execute "DELETE FROM greedy_ancestors;"
    TempDB.Execute "INSERT INTO greedy_ancestors (CUI, INCLUDE, ALLDESCENDENTS, TRUECHILDREN) SELECT DISTINCT SUPERTYPEID AS CUI, FALSE AS INCLUDE, 1 AS ALLDESCENDENTS, 0 AS TRUECHILDREN FROM greedy_tc;"
    If DebugOn Then PrintLog ("  " & TempDB.RecordsAffected & " unique candidate supertypes identified")
    TempDB.Execute "CREATE INDEX c_x ON greedy_ancestors(CUI);"
    
    'Annotate each ancestor with whether its a member of the FULL cluster
    TempDB.Execute "UPDATE greedy_ancestors a INNER JOIN greedy_list_f l ON l.CUI = a.CUI SET a.INCLUDE = TRUE;"
    
    'And annotate each ancestor with the number of children and descendants it has
    '(NB HIER table DNUM is total descendents excluding self; we need count of descendents including self)
    'The greedy_ancestors_metrics table at this point functions as a temporary working table when computing the metrics; it is never used to persist the computed metrics
    If DebugOn Then PrintLog ("Counting all ancestors and descendants for unique candidate supertypes")
    TempDB.Execute "DELETE FROM greedy_ancestors_metrics;"
    MyDB.Execute "INSERT INTO greedy_ancestors_metrics (CUI, ALLDESCENDENTS, ALLCHILDREN) SELECT a.CUI, (h.DNUM + 1) AS ALLDESCENDENTS, COUNT(h.CHILD) AS ALLCHILDREN FROM greedy_ancestors a " _
                 & "INNER JOIN " & strScheme & "HIER h ON h.PARENT = a.CUI GROUP BY a.CUI, h.PARENT, h.DNUM;"
    If DebugOn Then PrintLog ("  metrics computed for " & MyDB.RecordsAffected & " unique candidate supertypes")
    TempDB.Execute "CREATE INDEX cui_x ON greedy_ancestors_metrics(CUI);"
    TempDB.Execute "UPDATE greedy_ancestors a INNER JOIN greedy_ancestors_metrics m ON m.CUI = a.CUI SET a.ALLDESCENDENTS = m.ALLDESCENDENTS, a.ALLCHILDREN = m.ALLCHILDREN;"
    If DebugOn Then PrintLog ("  all descendent and children counts updated on " & TempDB.RecordsAffected & " unique candidate supertypes")
    
    'Count how many members of the FULL enumerated cluster set are direct children on each potential ancestor
    '(Split into two queries as Access won't do as a single JOIN)
    If DebugOn Then PrintLog ("Counting ancestors and descendants in enumerated cluster for unique candidate supertypes")
    TempDB.Execute "DROP INDEX cui_x ON greedy_ancestors_metrics;"
    TempDB.Execute "DELETE FROM greedy_ancestors_metrics;"
    MyDB.Execute "INSERT INTO greedy_ancestors_metrics (CUI, TRUECHILDREN) SELECT a.CUI, COUNT(h.CHILD) AS NUM FROM " _
                & "(greedy_ancestors a INNER JOIN " & strScheme & "HIER h ON h.PARENT = a.CUI) INNER JOIN greedy_list_f l ON h.CHILD = l.CUI GROUP BY a.CUI;"
    If DebugOn Then PrintLog ("  metrics computed for " & MyDB.RecordsAffected & " unique candidate supertypes")
    TempDB.Execute "CREATE INDEX cui_x ON greedy_ancestors_metrics(CUI);"
    TempDB.Execute "UPDATE greedy_ancestors a INNER JOIN greedy_ancestors_metrics m ON m.CUI = a.CUI SET a.TRUECHILDREN = m.TRUECHILDREN;"
    If DebugOn Then PrintLog ("  true children counts updated on " & TempDB.RecordsAffected & " unique candidate supertypes")
        
    'Count how many members (and episodes) of the FULL enumerated cluster set are subsumed by each potential ancestor
    '(Split into two queries as Access won't do as a single JOIN)
    TempDB.Execute "DELETE FROM greedy_int;"
    TempDB.Execute "INSERT INTO greedy_int SELECT a.CUI, COUNT(l.CUI) AS NUM " & IIf(FrequencyWeighted = True, ", SUM(l.FREQ) AS FREQ ", "") _
                 & "FROM (greedy_ancestors a INNER JOIN greedy_tc tc ON a.CUI = tc.SUPERTYPEID) INNER JOIN greedy_list_f l ON l.CUI = tc.SUBTYPEID GROUP BY a.CUI;"
    '..and use this to post TRUEPOS, TRUENEG and FREQ values into the greedy_ancestors table
    TempDB.Execute "UPDATE greedy_ancestors a1 INNER JOIN greedy_int x ON x.CUI = a1.CUI SET a1.TRUEPOS = x.NUM, a1.TRUENEG = a1.ALLDESCENDENTS - x.NUM" _
                   & IIf(FrequencyWeighted = True, ", a1.FREQ = x.FREQ;", ";")
    If DebugOn Then PrintLog ("  true +ve and true -ve descendent counts updated on " & TempDB.RecordsAffected & " unique candidate supertypes")
    
    'Take a backup of the full list of candidate ancestors; this is used in the section to find candidate exclusion ancestors
    'greedy_ancestors_metrics gets co-opted for this purpose.
    TempDB.Execute "DROP INDEX cui_x ON greedy_ancestors_metrics;"
    TempDB.Execute "DELETE FROM greedy_ancestors_metrics;"
    TempDB.Execute "INSERT INTO greedy_ancestors_metrics (CUI) SELECT CUI FROM greedy_ancestors;"
    TempDB.Execute "CREATE INDEX cui_x ON greedy_ancestors_metrics(CUI);"
    If DebugOn Then PrintLog ("  cacheing " & TempDB.RecordsAffected & " unique candidate supertypes")
    
    'Now discard any candidate ancestors that fail any minimum metric suitability criteria
    'Not enough true descendants
    TempDB.Execute "DELETE FROM greedy_ancestors WHERE TRUEPOS < " & MinimumClusterSize & ";"
    'All descendents, but not self, and only one true child
    TempDB.Execute "DELETE FROM greedy_ancestors WHERE TRUENEG = 1 AND INCLUDE = FALSE AND ALLCHILDREN = 1;"
    
    'Apply the date filter, if any was specified
    If TargetSchemeReleaseDateFilter <> "" Then
        If InStr("RCT CTV3 SCT", strScheme) > 0 Then
            MyDB.Execute "DELETE a.* FROM greedy_ancestors a INNER JOIN " & strScheme & " t ON (a.CUI = t.CUI) WHERE IIF(ASC(Left(t.RDATE,1)) > 55, '19','20') & t.RDATE " & Left(TargetSchemeReleaseDateFilter, 1) & " '" & Mid(TargetSchemeReleaseDateFilter, 2) & "';"
            PrintLog (MyDB.RecordsAffected & " candidate inclusion ancestor" & IIf(MyDB.RecordsAffected = 1, "", "s") & " suppressed because release date " & TargetSchemeReleaseDateFilter)
        End If
    End If
    
     If FrequencyWeighted = True Then
        'Not enough of the record summarised
        PrintLog ("Suppressing ancestors subsuming fewer than " & Round((TotalFrequency / 4000), 0) & " episodes")
        TempDB.Execute "DELETE FROM greedy_ancestors WHERE FREQ < " & (TotalFrequency / 4000)
        'Too much of the record summarised
        PrintLog ("Suppressing ancestors individually subsuming more than 10% of all episodes")
        TempDB.Execute "DELETE FROM greedy_ancestors WHERE FREQ > " & Round((TotalFrequency / 10), 0)
    Else
        'Too many exclusion clauses needed (probably)
        'TempDB.Execute "DELETE FROM greedy_ancestors WHERE ALLCHILDREN > 9 AND TRUECHILDREN < 6;"
        'TempDB.Execute "DELETE FROM greedy_ancestors WHERE (ALLCHILDREN - TRUECHILDREN) > 10;"
        If CompressionStrategy = 4 And FuzzyGroupingThreshold > 75 Then
            PrintLog "WARNING: Ultralossy compression enabled - permitting candidate ancestors where (ALL CHILDREN - TRUE CHILDREN) > TRUECHILDREN"
            PrintLog "WARNING: Ultralossy compression enabled - permitting candidate ancestors where ALL CHILDREN > 9 AND (TRUE CHILDREN / ALL CHILDREN) < 0.6"
        Else
            PrintLog "Discarding candidate ancestors where (ALL CHILDREN - TRUE CHILDREN) > TRUECHILDREN"
            PrintLog "Discarding candidate ancestors where ALL CHILDREN > 9 AND (TRUE CHILDREN / ALL CHILDREN) < 0.6"
            TempDB.Execute "DELETE FROM greedy_ancestors WHERE (ALLCHILDREN - TRUECHILDREN) > TRUECHILDREN;"
            TempDB.Execute "DELETE FROM greedy_ancestors WHERE ALLCHILDREN > 9 AND (TRUECHILDREN/ALLCHILDREN) < 0.6;"
        End If
    End If
    
    'Initialise iteration loop
    Zoom = IdealClauseCount
    WinnerExistsAtCurrentZoom = False
    ClauseNumber = 1
    ClauseCount = 1
    Iteration = 1
    'Parameters to prevent endless iteration
    TerminateNow = False
    MaxIterations = IIf(FrequencyWeighted = True, 2000, 1000)
    MaxElapsedTimeHours = 0.66
    ForceTerminationTime = Now() + (MaxElapsedTimeHours / 24)
        
    '261004008 diagnostic intent
    '707166002 allowlist
        
    If DebugOn Then PrintLog ("QUIT at " & ForceTerminationTime & " or after " & MaxIterations & " iterations")
    If DebugOn Then PrintLog ("START: FINDING INCLUSION CLAUSES")
    
    'Delete all redundant candidate ancestors with no true negative descendent ie those also subsumed by another candidate ancestor with no true negative descendent
    MyDB.Execute "DELETE a.* FROM (greedy_ancestors AS a INNER JOIN " & strScheme & "TC AS tc ON a.CUI = tc.SUBTYPEID) INNER JOIN greedy_ancestors AS b ON tc.SUPERTYPEID = b.CUI " _
               & "WHERE b.CUI <> a.CUI AND a.TRUENEG = 0 AND (b.TRUENEG = 0 OR (b.TRUENEG = 1 AND b.INCLUDE = FALSE));"
    
    If FrequencyWeighted = False Then
        'Accept as a batch all potential hierarchical ancestors with no exclusion clauses
        strSQL = "SELECT CUI AS strRES, Include, " & IIf(FrequencyWeighted = True, " FREQ,", "") & " TRUEPOS, SCORE FROM greedy_ancestors a WHERE TRUENEG = 0 OR (TRUENEG = 1 AND INCLUDE = FALSE)"        If CompressionStrategy = 4 Then
            'Or, if using lossy fuzzy compression, ancestors for which the ratio of true negative: all descendents is below the threshold
            strSQL = strSQL & " OR ((TRUENEG/ALLDESCENDENTS) < " & (FuzzyGroupingThreshold / 100) & ")"
            PrintLog "Option: Fuzzy refactoring; accepting inclusion clauses with < " & FuzzyGroupingThreshold & "% true negative members"
        End If
        Set myWinner = TempDB.OpenRecordset(strSQL)
        If Not (myWinner.BOF And myWinner.EOF) Then
            If DebugOn Then PrintLog ("START: Inclusion clauses with " & IIf(CompressionStrategy <> 4, "perfect", "acceptably Fuzzy") & " fit")
            myWinner.MoveFirst
            Do Until myWinner.EOF
                Winner = myWinner!strRes
                IncludeWinner = myWinner!include
                If DebugOn Then
                    strWinner = "Found Inclusion #" & ClauseNumber & " "
                    'If FrequencyWeighted = True Then strWinner = strWinner & "(" & myWinner!FREQ & " " & Round((myWinner!FREQ / TotalFrequency) * 100, 3) & "%) "
                    strWinner = strWinner & IIf(IncludeWinner = True, "<<", " <") & DisplayCode(Winner, strScheme, , , True)
                    PrintLog strWinner
                End If
                'Post the winner into the output table
                'Greedy Output : CLUSTERID CLAUSENUM SCORE INCLUDE EXTENSION CUI DESCENDENTS TRUEPOS TRUENEG ZOOM LISTSIZE
                MyDB.Execute "INSERT INTO Query_Refactored SELECT DISTINCT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, SCORE AS SCORE, TRUE AS INCLUDE, " _
                           & IIf(IncludeWinner = True, "'<<'", "'<'") & " AS EXTENSION, '" & Winner & "' AS CUI, ALLDESCENDENTS AS DESCENDENTS, TRUEPOS AS TRUEPOS, TRUENEG AS TRUENEG, " _
                           & Zoom & " AS ZOOM, " & FullListSize & " AS LISTSIZE FROM greedy_ancestors a WHERE a.CUI = '" & Winner & "';"
                           
                If CompressionStrategy = 4 Then
                    'Prune the relevant sticky exclusion clauses
                    i = 1
                    LogLevel = LogLevel + 1
                    Do Until i > StickyExclusions.ClauseCount
                        Set myClause = New Clause
                        xWinner = StickyExclusions.Clause(i, myClause)
                        If subsumes(Winner, myClause.CUI, strScheme) Then
                            StickyExclusions.DeleteClause myClause
                        Else
                            i = i + 1
                        End If
                    Loop
                    LogLevel = LogLevel - 1
                End If
                
                ClauseNumber = ClauseNumber + 1
                ClauseCount = ClauseCount + 1
                myWinner.MoveNext
            Loop
            MaxClauseCount = IIf((ClauseNumber * 2) < MaxClauseCount, MaxClauseCount, (ClauseNumber * 2))
            'Remove the winners from the set of ancestors to be considered in subsequent iterations
            strSQL = "DELETE * FROM greedy_ancestors WHERE TRUENEG = 0 OR (TRUENEG = 1 AND INCLUDE = FALSE)" _
                   & IIf(CompressionStrategy = 4, " OR ((TRUENEG/ALLDESCENDENTS) < " & (FuzzyGroupingThreshold / 100) & ")", "")
            TempDB.Execute strSQL
            'Remove all codes covered by the new clauses from the code set to be considered in subsequent iterations
            TempDB.Execute "DELETE l.* FROM greedy_list l INNER JOIN (Query_Refactored i INNER JOIN greedy_tc tc ON i.CUI = tc.SUPERTYPEID) ON tc.SUBTYPEID = l.CUI;"
            If DebugOn Then PrintLog ("DONE: Inclusion clauses with " & IIf(CompressionStrategy <> 4, "perfect", "acceptably Fuzzy") & " fit")
        End If
    End If
   
    PartialListSize = SQLCount("SELECT COUNT(CUI) AS RES FROM greedy_list", TempDB)
    
    If DebugOn Then PrintLog ("START: Iterate over inclusion clauses needing exclusions")
    
    If WithExclusions = False And FrequencyWeighted = False Then
        TerminateNow = True
        If DebugOn Then PrintLog ("Exiting: Option was set to refactor WITHOUT using exclusion clauses")
    End If
    
    Do Until (TerminateNow = True) Or (CancelCurrentOperation = True)
        ListSize = SQLCount("SELECT COUNT(CUI) AS RES FROM greedy_list", TempDB)
        If DoProgress Then Call ShowProgress(PartialListSize - ListSize, PartialListSize)
        If ListSize = 0 Then Exit Do
        
        Select Case ListSize
            'Just because all concepts to be implied by the cluster definition are already covered by the union of all
            'clauses selected so far doesn't mean that a more abstract candidate doesn't exist in the candidate list
            'that would make redundant MORE perfect fit clauses than it would have to create as exclusion clauses!
            'So, don't terminate just because the concepts to be implied by the definition are already covered
            
'            Case Is = 0
'                TerminateNow = True
'            Case Is = 1
'                If DebugOn Then PrintLog ("Only one code to be included; no point attempting to group.")
'                TerminateNow = True
            Case Else
            PrintLog (IIf(DebugOn, "Iteration #" & Iteration & " : LSize=" & ListSize & " Fit=" & FitThreshold & " Z=" & Zoom & IIf(FrequencyWeighted = True, " c=" & Round((ListCoverage / TotalFrequency) * 100, 1) & "%", ""), "BLINK"))
                
            If FrequencyWeighted = False Then
                'RANKING OF POTENTIAL ANCESTORS WITHOUT FREQUENCY WEIGHTING
                'The basic Fit of a potential ancestor is simply the number of true positives it subsumes from the enumerated cluster as a proportion of all concepts it subsumes
                'A Fit of 1, therefore, means that all the concepts subsumed by the ancestor are also members of the enumerated set:
                TempDB.Execute "UPDATE greedy_ancestors SET SCORE = (TRUEPOS/ALLDESCENDENTS);"
                    
                'Optional score weighting elements
                Select Case CompressionStrategy
                    Case Is = 1
                        'Default strategy; no additional score weighting
                    Case Is = 2
                        'Favour 'descendents only' clauses with lots of true negative descendents but not many true negative children
                        TempDB.Execute "UPDATE greedy_ancestors SET SCORE = SCORE + ((TRUECHILDREN/ALLCHILDREN)/2) WHERE SCORE < 0.4 AND ALLCHILDREN > 6 AND (TRUECHILDREN/ALLCHILDREN) > 0.8;"
                    Case Is = 3
                        'Strongly favour 'descendents only' clauses with lots of true negative descendents but not many true negative children
                        TempDB.Execute "UPDATE greedy_ancestors SET SCORE = SCORE + (TRUECHILDREN/ALLCHILDREN);"                End Select
                    
                'Weighting to favour 'self and descendents' clauses a little over 'descendents only'
                TempDB.Execute "UPDATE greedy_ancestors SET SCORE = (SCORE * 0.95) WHERE INCLUDE = FALSE;"
                
                'To manage the trade-off between getting lots of very high fit but small clauses vs only a few clauses but each with poor fit
                '(and, therefore, loads of exceptions), the overall score for those clauses with anything less than wonderful fit (Basic Fit > 0.7)
                'is the Basic Fit multiplied by a weighting function that exponentially promotes candidate ancestors as the number of members
                '(or volume of the EPR) they subsume approaches the ideal clause size.
                'However, the weighting function is also (if necessary) dynamically tuned as the algorithm runs, by adjusting the Zoom value
                TempDB.Execute "UPDATE greedy_ancestors SET SCORE = (SCORE * ((1/(ABS((" & FullListSize & "/TRUEPOS) - " & Zoom & ") +1)) ^ " & ClauseCountWeighting & ")) WHERE SCORE > 0 AND SCORE <0.7;"
            Else
                'RANKING OF POTENTIAL ANCESTORS WITH FREQUENCY WEIGHTING
                'The basic score of a frequency-weighted potential ancestor is a measure of how closely it conforms to the target average cluster coverage (aka zoom)
                'We're not interested in whether the ancestor has other descendant codes that aren't used in the instance data - we just want to find
                'the set of minimally abstracted supertypes that are collectively sufficient to subsume the target proportion of all coded content
                TempDB.Execute "UPDATE greedy_ancestors SET SCORE = 1/(ABS((" & TotalFrequency & "/FREQ) - " & Zoom & "));"
                
                'Multiply the basic score by a weighting function that favours groupings of lots of codes with low individual usage
                'over clusters subsuming a small number of codes but each of which is used very frequently
                TempDB.Execute "UPDATE greedy_ancestors SET SCORE = (SCORE * (1-(1/(FREQ/TRUEPOS)))) WHERE SCORE > 0;"
                
                ListCoverage = SQLCount("SELECT SUM(FREQ) AS RES FROM greedy_list", TempDB)
            End If
            
            'The winning ancestor in this iteration, if there is one, is the one with the highest score but that ALSO has a Fit above the current Fit threshold
            strSQL = "SELECT CUI AS strRES, Include, " & IIf(FrequencyWeighted = True, " FREQ,", "") & " TRUEPOS, SCORE, TRUENEG FROM greedy_ancestors a WHERE a.SCORE = (SELECT MAX(b.SCORE) FROM greedy_ancestors b WHERE b.SCORE >= " & FitThreshold & ") ORDER BY CUI DESC;"
            Set myWinner = TempDB.OpenRecordset(strSQL)
                        
            If Not (myWinner.BOF And myWinner.EOF) Then
                'If a winner exists (or, if more than one with the same maximum score, then arbitrarily one winner)
                myWinner.MoveFirst
                Winner = myWinner!strRes
'                If Winner = "716458004" Then Stop

                'Flag up that a winner HAS been found (and so stop the weighting algorithm from being detuned this time around)
                WinnerExistsAtCurrentZoom = True
                
                'Determine whether the ancestor is itself a member of the enumerated cluster set (ie whether clause definition is self and descendants or descendants only
                IncludeWinner = myWinner!include
                                             
                strWinner = "Found Inclusion #" & ClauseNumber & " "
                If FrequencyWeighted = True Then strWinner = strWinner & "(" & myWinner!FREQ & " " & Round((myWinner!FREQ / TotalFrequency) * 100, 3) & "%) "
                strWinner = strWinner & IIf(IncludeWinner = True, "<<", " <") & DisplayCode(Winner, strScheme, , , True)
                
                'Post the winner into the output table
                'Greedy Output : CLUSTERID CLAUSENUM SCORE INCLUDE EXTENSION CUI DESCENDENTS TRUEPOS TRUENEG ZOOM LISTSIZE
                MyDB.Execute "INSERT INTO Query_Refactored SELECT DISTINCT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, SCORE AS SCORE, TRUE AS INCLUDE, " _
                           & IIf(IncludeWinner = True, "'<<'", "'<'") & " AS EXTENSION, '" & Winner & "' AS CUI, ALLDESCENDENTS AS DESCENDENTS, TRUEPOS AS TRUEPOS, TRUENEG AS TRUENEG, " _
                           & Zoom & " AS ZOOM, " & ListSize & " AS LISTSIZE FROM greedy_ancestors a WHERE a.CUI = '" & Winner & "';"
                
                If myWinner!TRUENEG = 0 Or (myWinner!TRUENEG = 1 And myWinner!include = False) Then
                    LogLevel = LogLevel + 1
                    If DebugOn Then PrintLog (strWinner & " with no exclusions needed")
                    LogLevel = IIf(LogLevel > 0, LogLevel - 1, 0)
                Else
                    NeedsExclusions = True
                    If WithExclusions = False Then
                        LogLevel = LogLevel + 1
                        If DebugOn Then PrintLog (strWinner & " (subsumes concepts outside input scope, but option set for no exclusion clauses)")
                        If FrequencyWeighted = True Then PrintLog "Coverage " & Round((myWinner!FREQ / TotalFrequency) * 100, 3) & "% by grouping " & myWinner!TRUEPOS & " codes, score=" & myWinner!SCORE
                        LogLevel = IIf(LogLevel > 0, LogLevel - 1, 0)
                     Else
                        'EXTRACT THE EXCLUSION SET TO THE CUMULATIVE EXLCUSION LIST
                        'Identify the set of concepts that ARE in the current cluster extension but were NOT in the original set
                        If DebugOn Then PrintLog (strWinner & " but exclusions clauses will be needed")
                        On Error Resume Next
                        TempDB.Execute "DROP INDEX id_x ON greedy_temp;"
                        TempDB.Execute "DELETE FROM greedy_temp;"
                        On Error GoTo GroupCodesInSet_Error
                        'Pull ALL concepts implied by the winning clause from the FULL transitive closure table for the scheme
                        strSQL = "INSERT INTO greedy_temp SELECT tc.SUBTYPEID AS CUI FROM " & strScheme & "TC tc WHERE tc.SUPERTYPEID = '" & Winner & "'"
                        If IncludeWinner = 0 Then strSQL = strSQL & " AND SUBTYPEID <> SUPERTYPEID"
                        MyDB.Execute strSQL
                        TempDB.Execute "CREATE INDEX id_x ON greedy_temp(CUI);"
                        'Add to the exclusion set all those descendants of the winner NOT also in the full enumeration of the original cluster
                        TempDB.Execute "INSERT INTO greedy_exclusion_list SELECT x.CUI AS CUI, '" & ClusterID & "' AS ID FROM greedy_temp x LEFT JOIN greedy_list_f l ON x.CUI = l.CUI WHERE ISNULL(l.CUI);"
                     End If
                End If
                
                'Remove all those codes covered by the new clause from the code set to be considered in subsequent iterations
                TempDB.Execute "DELETE l.* FROM greedy_list l INNER JOIN greedy_tc tc ON tc.SUBTYPEID = l.CUI WHERE STRCOMP(tc.SUPERTYPEID, '" & Winner & "',0) = 0;"
                ClauseCoverage = TempDB.RecordsAffected
                
                If (FullListSize / (ClauseCoverage + 1)) > 1000 Then
                    NewFitThreshold = Round((FitThreshold * 0.9), 3)
                    If (NewFitThreshold > MinimumFitThreshold And NewFitThreshold < FitThreshold) Then
                        'As long as the proposed new FitThreshold is above some minimum floor Fit level
                        '(and also as long as its actually different from the current FitThreshold...)
                        'then accept it, and reset the Zoom to the normal starting level for each pass
                        If DebugOn Then PrintLog "Winning clause was too small (" & ClauseCoverage & " true +ve); detuning"
                        FitThreshold = NewFitThreshold
                        Zoom = IdealClauseCount
                    End If
                    If Iteration > (CompressionStrategy * 100) And CompressionStrategy < 3 Then
                        If DebugOn Then
                            PrintLog "This is taking ages; I'm going to loosen the refactoring strategy from " & CompressionStrategy & " to " & (CompressionStrategy + 1)
                            PrintLog "(Don't panic : the pre- and post-refactoring definitions will still generate the same memberlist)"
                        End If
                        CompressionStrategy = CompressionStrategy + 1
                    End If
                End If
                
                'Remove the winner, and all descendants of the winner, from the set of ancestors to be considered in subsequent iterations
                TempDB.Execute "DELETE a.* FROM greedy_ancestors a INNER JOIN greedy_tc tc ON tc.SUBTYPEID = a.CUI WHERE tc.SUPERTYPEID = '" & Winner & "';"
                TempDB.Execute "DELETE FROM greedy_ancestors WHERE CUI = '" & Winner & "';"
                ClauseNumber = ClauseNumber + 1
                ClauseCount = ClauseCount + 1
            Else
                'If no winner was found on this pass, then try to (de)tune the score weighting function
                'so that smaller and/or less well fitting clauses are allowed:
                If Zoom <= MaxClauseCount And Zoom <= ListSize And Zoom <> Round((Zoom * 1.1) + 0.5, 0) Then
                  'Initially, simply increment the Zoom (as long as it hasn't hit the MaxClauseCount buffer)
                  'This shifts the weighting function toward favouring smaller clusters that might have Fit above the current
                  'threshold but that currently score lower than some larger cluster but with sub-threshold Fit
                  Zoom = Round((Zoom * 1.1) + 0.5, 0)
                Else
                  'Zoom has already hit the buffers (ie we're already considering the smallest clusters we're interested in getting)
                  If WinnerExistsAtCurrentZoom = False Then
                    'If no winner has been found in any pass at ANY Zoom level and with the prevailing FitThreshold
                    'then propose a revised FitThreshold that's just low enough to allow the currently highest scoring clause to pass through
                    If FrequencyWeighted = False Then
                        'NewFitThreshold = SQLCount("SELECT ROUND((a.TRUEPOS/a.ALLDESCENDENTS),3) AS Res FROM greedy_ancestors a WHERE a.SCORE = (SELECT MAX(b.SCORE) FROM greedy_ancestors b)", TempDB)
                        NewFitThreshold = SQLCount("SELECT MAX(SCORE) AS RES FROM greedy_ancestors", TempDB)
                    Else
                        NewFitThreshold = SQLCount("SELECT ((1/(ABS((" & TotalFrequency & "/FREQ) - " & Zoom & ") +1)) ^ " & ClauseCountWeighting & ") AS Res FROM greedy_ancestors a WHERE a.SCORE = (SELECT MAX(b.SCORE) FROM greedy_ancestors b)", TempDB)
                    End If
                    If DebugOn Then PrintLog ("INCLUSION FIT THRESHOLD VALUE RECALIBRATION")
                  Else
                    'If a winner HAS previously been found at SOME zoom level and with the prevailing FitThreshold
                    'then propose a less drastically lowered FitThreshold
                    NewFitThreshold = Round((FitThreshold * 0.9), 3)
                  End If
                  If (NewFitThreshold > MinimumFitThreshold And NewFitThreshold < FitThreshold) Then
                    'As long as the proposed new FitThreshold is above some minimum floor Fit level
                    '(and also as long as its actually different from the current FitThreshold...)
                    'then accept it, and reset the Zoom to the normal starting level for each pass
                    FitThreshold = NewFitThreshold
                    Zoom = IdealClauseCount
                    WinnerExistsAtCurrentZoom = False
                  Else
                    'Otherwise we've hit the buffers: the weighting function can't be (de)tuned any further
                    If DebugOn Then
                        PrintLog ("TERMINATING: Can't detune inclusion weighting function any further")
                        PrintLog "Next best fitting candidate has score of " & Round(NewFitThreshold, 5)
                        PrintLog "Minimum fit threshold is " & MinimumFitThreshold
                    End If
                    TerminateNow = True
                  End If
                End If
            End If
            Iteration = Iteration + 1
            
            'Determine whether to exit the inclusion clause-finding loop
            If (ClauseCount > MaxClauseCount) Then
                If DebugOn Then PrintLog ("Compacting clauses...")
                MyDB.Execute "DELETE a.* FROM QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON a.CUI = b.CUI AND a.INCLUDE = b.INCLUDE AND a.EXTENSION = b.EXTENSION WHERE a.CLAUSENUM < b.CLAUSENUM;"
                Residue = MyDB.RecordsAffected
                If DebugOn And Residue > 0 Then PrintLog Residue & " duplicate clause" & IIf(Residue = 1, "", "s") & " pruned"
                'remove < clauses on a concept if a << clause exists on the same concept (technically, this situation shouldn't arise ... but just in case)
                MyDB.Execute "DELETE a.* FROM QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON a.CUI = b.CUI AND a.INCLUDE = b.INCLUDE WHERE a.EXTENSION = '<' AND b.EXTENSION = '<<';"
                'remove clauses that are subsumed by another clause with << or < extension
                MyDB.Execute "DELETE a.* FROM (QUERY_REFACTORED AS a INNER JOIN " & strScheme & "TC AS tc ON a.CUI = tc.SUBTYPEID) INNER JOIN QUERY_REFACTORED AS b ON tc.SUPERTYPEID = b.CUI " _
                           & "WHERE b.EXTENSION IN ('<','<<') AND b.CUI <> a.CUI AND a.INCLUDE = b.INCLUDE;"
                Residue = MyDB.RecordsAffected
                If DebugOn And Residue > 0 Then PrintLog Residue & " redundant clause" & IIf(Residue = 1, "", "s") & " pruned"
                ClauseCount = SQLCount("SELECT COUNT(CLAUSENUM) AS RES FROM (SELECT DISTINCT CLAUSENUM FROM QUERY_REFACTORED) x;")
                If ClauseCount > MaxClauseCount Then
                    If DebugOn Then PrintLog ("TERMINATING: reached maximum requested number of clauses! (" & MaxClauseCount & ")")
                    TerminateNow = True
                End If
            End If
            If FrequencyWeighted = True Then
                If ((SQLCount("SELECT SUM(FREQ) AS RES FROM greedy_list;") / TotalFrequency) * 100) < (100 - MaxCoverage) Then
                    If DebugOn Then PrintLog ("TERMINATING: " & ClauseNumber & " clauses found cover >" & MaxCoverage & "% of record, as per target")
                    TerminateNow = True
                End If
            End If
            If (Iteration > MaxIterations) Then
                If DebugOn Then PrintLog ("TERMINATING: done maximum number of allowed iterations! (" & MaxIterations & ")")
                TerminateNow = True
            End If
            If (Now() > ForceTerminationTime) Then
                If DebugOn Then PrintLog ("TERMINATING: Spent too long trying to find clusters!")
                TerminateNow = True
            End If
        End Select
    Loop
    
    If CancelCurrentOperation = True Then GoTo GroupCodesInSet_Abort
    
    If DebugOn Then PrintLog ("DONE: Iterate over inclusion clauses needing exclusions")
       
    'Deal with the residue of codes in the enumerated cluster set that couldn't be grouped
    Residue = SQLCount("SELECT COUNT(CUI) AS RES FROM greedy_list;", TempDB)
    
    If FrequencyWeighted = False Then
        If DebugOn Then PrintLog (Residue & " concepts could not be grouped" & IIf(Residue > 0, "; dumping as '=' clauses", ""))
        'Greedy Output : CLUSTERID CLAUSENUM  SCORE  INCLUDE  EXTENSION  CUI DESCENDENTS TRUEPOS TRUENEG ZOOM LISTSIZE
        If Residue > 0 Then
            MyDB.Execute "INSERT INTO QUERY_REFACTORED SELECT DISTINCT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, 1 AS SCORE, TRUE AS INCLUDE, " _
                       & "IIF(ISNULL(h.PARENT),'<<','=') AS EXTENSION, x.CUI AS CUI,0 AS DESCENDENTS,0 AS TRUEPOS,0 AS TRUENEG," & Zoom & " AS ZOOM, " & ListSize & " AS LISTSIZE " _
                       & "FROM greedy_list AS x LEFT JOIN " & strScheme & "HIER AS h ON x.CUI = h.PARENT;"
        End If
    Else
        If DebugOn Then
            strWinner = Residue & " concept" & IIf(Residue = 1, " was", "s were") & " ungrouped and ommitted from cluster scope"
            Residue = SQLCount("SELECT SUM(FREQ) AS RES FROM greedy_list;", TempDB)
            strWinner = strWinner & " (ie cluster scope excludes " & Residue & " EPR episode" & IIf(Residue = 1, "", "s") & " or " & Round((Residue / TotalFrequency) * 100, 1) & "% of total EPR content)"
            PrintLog strWinner
        End If
    End If
    
    If DebugOn Then PrintLog ("DONE: FINDING INCLUSION CLAUSES")
    
    On Error Resume Next
    TempDB.Execute "DROP INDEX id_x ON greedy_temp;"
    TempDB.Execute "DELETE FROM greedy_temp;"
    On Error GoTo GroupCodesInSet_Error
        
    If (StickyExclusions.ClauseCount > 0 And WithExclusions = True) Then
        If DebugOn Then PrintLog ("START: Inject " & StickyExclusions.ClauseCount & " sticky exclusion clause" & IIf(StickyExclusions.ClauseCount = 1, "", "s"))
        str = ""
        For i = 1 To StickyExclusions.ClauseCount
            Set myClause = New Clause
            xWinner = StickyExclusions.Clause(i, myClause)
            strRule = myClause.extension
            xWinner = myClause.CUI
            If InStr(str, strRule & xWinner) = 0 Then ' do not add the same sticky clause more than once
                str = str & strRule & xWinner & "|" ' keep track of the sticky clauses added so far
                
                If SQLCount("SELECT COUNT(ID) AS RES FROM QUERY_REFACTORED WHERE ID = '" & ClusterID & "' AND INCLUDE = FALSE AND EXTENSION = '" & strRule & "' AND CUI = '" & xWinner & "';", MyDB) = 0 Then
                    PrintLog ("@-" & strRule & DisplayCode(xWinner, strScheme))
                Else
                    PrintLog ("@-" & strRule & DisplayCode(xWinner, strScheme) & " REDUNDANT")
                End If
                
                If (NeedsExclusions = True And WithExclusions = True) Then
                    'Don't need to enumerate the exclusions from each sticky exclusion clause if, in fact, there are no concepts that need excluding
                    'But the sticky clauses still get stuck in
                    strSQL = ""
                    Select Case strRule
                        Case Is = "="
                            strSQL = "INSERT INTO greedy_temp SELECT '" & xWinner & "' AS CUI;"
                        Case Is = "<"
                            strSQL = "INSERT INTO greedy_temp SELECT tc.SUBTYPEID AS CUI FROM " & strScheme & "TC tc WHERE tc.SUPERTYPEID = '" & xWinner & "' AND SUBTYPEID <> SUPERTYPEID"
                        Case Is = "<<"
                            strSQL = "INSERT INTO greedy_temp SELECT tc.SUBTYPEID AS CUI FROM " & strScheme & "TC tc WHERE tc.SUPERTYPEID = '" & xWinner & "';"
                        Case Is = ":<"
                            ClauseSyntax = "EXTENDED"
                            strSQL = "INSERT INTO greedy_temp SELECT r.CUI AS CUI FROM (SCTTC tc INNER JOIN SCTREL r ON (tc.SUPERTYPEID = '" & xWinner & "' AND tc.SUBTYPEID = r.CUI2)) INNER JOIN SCTMODREL a ON (r.REL = a.REL AND a.ALLOWED = TRUE);"
                        Case Is = ":="
                            ClauseSyntax = "EXTENDED"
                            strSQL = "INSERT INTO greedy_temp SELECT r.CUI AS CUI FROM SCTREL r INNER JOIN SCTMODREL a ON (r.REL = a.REL AND a.ALLOWED = TRUE) WHERE r.CUI2 = '" & xWinner & "';"
                    End Select
                    MyDB.Execute strSQL
                End If
                
                MyDB.Execute "INSERT INTO QUERY_REFACTORED SELECT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, 0 AS SCORE, TRUE AS STICKY, FALSE AS INCLUDE, " _
                             & "'" & strRule & "' AS EXTENSION, '" & xWinner & "' AS CUI,0 AS DESCENDENTS,0 AS TRUEPOS,0 AS TRUENEG,0 AS ZOOM, 0 AS LISTSIZE;"
                ClauseNumber = ClauseNumber + 1
                ClauseCount = ClauseCount + 1
            End If
        Next i
        If DebugOn Then PrintLog ("DONE: Inject sticky exclusion clauses")
    End If
        
    If (AllowListExclusions.ClauseCount > 0 And WithExclusions = True) Then
        If DebugOn Then PrintLog ("START: Inject non-sticky allowlist exclusion clauses")
        For i = 1 To AllowListExclusions.ClauseCount
            Set myClause = New Clause
            xWinner = AllowListExclusions.Clause(i, myClause)
            strRule = myClause.extension
            xWinner = myClause.CUI
            If SQLCount("SELECT COUNT(ID) AS RES FROM QUERY_REFACTORED WHERE ID = '" & ClusterID & "' AND INCLUDE = FALSE AND EXTENSION = '" & strRule & "' AND CUI = '" & xWinner & "';", MyDB) = 0 Then
                PrintLog ("-" & strRule & DisplayCode(xWinner, strScheme))
            Else
                PrintLog ("-" & strRule & DisplayCode(xWinner, strScheme) & " REDUNDANT")
            End If
            
            If (NeedsExclusions = True And WithExclusions = True) Then
                'Don't need to enumerate the exclusions from each allowlist exclusion clause if,
                'there are no concepts that need excluding
                Select Case strRule
                    Case Is = "=", "<<"
                        strSQL = "INSERT INTO greedy_temp SELECT '" & xWinner & "' AS CUI;"
                    Case Else
                        'Neither the descendents of allowlisted concepts nor their modelled relationships are known
                        strSQL = ""
                End Select
                MyDB.Execute strSQL
            End If
            
            MyDB.Execute "INSERT INTO QUERY_REFACTORED SELECT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, 0 AS SCORE, FALSE AS STICKY, FALSE AS INCLUDE, " _
                         & "'" & strRule & "' AS EXTENSION, '" & xWinner & "' AS CUI,0 AS DESCENDENTS,0 AS TRUEPOS,0 AS TRUENEG,0 AS ZOOM, 0 AS LISTSIZE;"
            ClauseNumber = ClauseNumber + 1
            ClauseCount = ClauseCount + 1
        Next i
        If DebugOn Then PrintLog ("DONE: Inject non-sticky allowlist exclusion clauses")
    End If
        
    TempDB.Execute "CREATE INDEX id_x ON greedy_temp(CUI);"
    
    ' Now refactor the cumulative exclusion list, if one has been detected to be needed
    If (NeedsExclusions = True And WithExclusions = True) Then
        If DebugOn Then PrintLog ("START: FINDING EXCLUSION CLAUSES")
        TempDB.Execute "CREATE INDEX c_x ON greedy_exclusion_list(CUI);"
        TempDB.Execute "INSERT INTO greedy_list_x SELECT DISTINCT CUI,ID FROM greedy_exclusion_list;"
        TempDB.Execute "CREATE INDEX c_x ON greedy_list_x(CUI);"
        xListSize = SQLCount("SELECT COUNT(CUI) AS RES FROM greedy_list_x", TempDB)
                        
        'Remove all members of the exclusion set that are covered by the sticky exclusion clauses
        TempDB.Execute "DELETE l.* FROM greedy_list_x l INNER JOIN greedy_temp t ON t.CUI = l.CUI;"
                        
        'Look for candidate modelled relationship values
        If strScheme = "SCT" And ClauseSyntax = "EXTENDED" Then
            If DebugOn Then PrintLog ("Collating unique values for all SNOMED CT modelled relationships on exclusion set concepts")
            MyDB.Execute "INSERT INTO greedy_vals SELECT r.CUI2 AS CUI, COUNT(CUI) AS TRUEPOS FROM greedy_list_x l INNER JOIN (SCTREL r INNER JOIN SCTMODREL a ON (r.REL = a.REL AND a.ALLOWED = TRUE)) ON l.CUI = r.CUI " & IIf(ClusterID <> "", " WHERE l.ID = '" & ClusterID & "'", "") & " GROUP BY r.CUI2;"
            TempDB.Execute "CREATE INDEX c_x ON greedy_vals(CUI);"
    
            MyDB.Execute "INSERT INTO greedy_vals_x SELECT r.CUI2 AS CUI, COUNT(r.CUI) AS TRUEPOS FROM greedy_vals l INNER JOIN (SCTREL r INNER JOIN SCTMODREL a ON (r.REL = a.REL AND a.ALLOWED = TRUE)) ON l.CUI = r.CUI2 GROUP BY r.CUI2;"
            TempDB.Execute "CREATE INDEX c_x ON greedy_vals_x(CUI);"
            TempDB.Execute "UPDATE greedy_vals v INNER JOIN greedy_vals_x x ON v.CUI = x.CUI SET v.ALLCUI = x.TRUEPOS, v.TRUENEG = x.TRUEPOS - v.TRUEPOS, v.SCORE = (v.TRUEPOS/x.TRUEPOS);"
            TempDB.Execute "DELETE FROM greedy_vals WHERE TRUENEG > 0;"
            TempDB.Execute "DELETE FROM greedy_vals_x;"
            If SQLCount("SELECT COUNT(CUI) AS RES FROM greedy_vals;") > 0 Then
                'Accept as a batch all surviving modelled values
                strSQL = "SELECT CUI as strRes, TRUEPOS, SCORE FROM greedy_vals;"
                Set myWinner = TempDB.OpenRecordset(strSQL)
                If Not (myWinner.BOF And myWinner.EOF) Then
                    If DebugOn Then PrintLog ("START: Modelled value clauses")
                    myWinner.MoveFirst
                    Do Until myWinner.EOF
                        Winner = myWinner!strRes
                        If DebugOn Then
                            strWinner = "Found Modelled Value Exclusion #" & ClauseNumber & " "
                            strWinner = strWinner & "-:=" & DisplayCode(Winner, strScheme, , , True)
                            PrintLog strWinner
                        End If
                        'Post the winner into the output table
                        'Greedy Output : CLUSTERID CLAUSENUM SCORE INCLUDE EXTENSION CUI DESCENDENTS TRUEPOS TRUENEG ZOOM LISTSIZE
                        MyDB.Execute "INSERT INTO Query_Refactored SELECT DISTINCT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, SCORE AS SCORE, " _
                                   & "FALSE AS INCLUDE, ':=' AS EXTENSION, '" & Winner & "' AS CUI, ALLCUI AS DESCENDENTS, TRUEPOS AS TRUEPOS, TRUENEG AS TRUENEG, " _
                                   & Zoom & " AS ZOOM, " & FullListSize & " AS LISTSIZE FROM greedy_vals a WHERE a.CUI = '" & Winner & "';"
                        
                        ClauseNumber = ClauseNumber + 1
                        ClauseCount = ClauseCount + 1
                        myWinner.MoveNext
                    Loop
                    'Remove all codes covered by the new exclusion clauses from the code set to be considered in subsequent iterations
                    MyDB.Execute "DELETE l.* FROM greedy_list_x l INNER JOIN (SCTREL r INNER JOIN greedy_vals v ON r.CUI2 = v.CUI) ON l.CUI = r.CUI;"
                                        
                    If DebugOn Then PrintLog ("DONE: Modelled value clauses")
                End If
            End If
        End If
        
        If CancelCurrentOperation = True Then GoTo GroupCodesInSet_Abort
        
        'Extract from the full transitive closure table only those rows relating to concepts that are an ancestor of ANY code still in the exclusion set
        If DebugOn Then PrintLog ("Extracting fragment of full transitive closure table for " & xListSize & " exclusion candidates")
        MyDB.Execute "INSERT INTO greedy_tc_x SELECT tc.SUPERTYPEID, tc.SUBTYPEID FROM " & strScheme & "TC tc INNER JOIN greedy_list_x l ON l.CUI = tc.SUBTYPEID;"
        TempDB.Execute "CREATE INDEX sb_x ON greedy_tc_x(SUBTYPEID);"
        TempDB.Execute "CREATE INDEX sp_x ON greedy_tc_x(SUPERTYPEID);"
               
        'Then identify the list of unique ancestors
        TempDB.Execute "DELETE FROM greedy_ancestors_x;"
        TempDB.Execute "INSERT INTO greedy_ancestors_x (CUI, INCLUDE, ALLDESCENDENTS) SELECT DISTINCT SUPERTYPEID AS CUI, FALSE AS INCLUDE, 1 AS ALLDESCENDENTS FROM greedy_tc_x;"
        If DebugOn Then PrintLog ("Collated list of " & TempDB.RecordsAffected & " exclusion candidate supertypes")
        TempDB.Execute "CREATE INDEX c_x ON greedy_ancestors_x(CUI);"
        TempDB.Execute "UPDATE greedy_ancestors_x a INNER JOIN greedy_list_x l ON l.CUI = a.CUI SET a.INCLUDE = TRUE;"
        
        'Apply the date filter, if any was specified
        If TargetSchemeReleaseDateFilter <> "" Then
            If InStr("RCT CTV3 SCT", strScheme) > 0 Then
                MyDB.Execute "DELETE a.* FROM greedy_ancestors_x a INNER JOIN " & strScheme & " t ON a.CUI = t.CUI WHERE IIF(ASC(Left(t.RDATE,1)) > 55, '19','20') & t.RDATE " & Left(TargetSchemeReleaseDateFilter, 1) & " '" & Mid(TargetSchemeReleaseDateFilter, 2) & "';"
                PrintLog (MyDB.RecordsAffected & " candidate exclusion ancestor" & IIf(MyDB.RecordsAffected = 1, "", "s") & " suppressed because release date " & TargetSchemeReleaseDateFilter)
            End If
        End If
        
        If CancelCurrentOperation = True Then GoTo GroupCodesInSet_Abort
        
        'Delete any candidate exclusions ancestors that are ALSO an ancestor of an inclusion set concept
        'ie we can't use it as an exclusion set ancestor because it would also act to exclude concepts that we want to include
        '(greedy_ancestors_metrics was previously populated with all possible ancestors of all included concepts)
        'MyDB.Execute "DELETE a.* FROM (greedy_ancestors_x a INNER JOIN " & strScheme & "TC tc ON a.CUI = tc.SUPERTYPEID) INNER JOIN greedy_list_f i ON i.CUI = tc.SUBTYPEID;"
        TempDB.Execute "DELETE a.* FROM greedy_ancestors_x a INNER JOIN greedy_ancestors_metrics m ON a.CUI = m.CUI;"
        TempDB.Execute "UPDATE greedy_ancestors_x SET TRUENEG = 0;"
        If DebugOn Then PrintLog (TempDB.RecordsAffected & " candidate exclusion ancestors discarded because also an inclusion ancestor")
        
        'Annotate each surviving candidate ancestor with the number of children and descendants it has (NB a figure already in the HIER table but that doesn't include itself)
        If DebugOn Then PrintLog ("Counting all ancestors and descendants for unique exclusion clause candidate supertypes")
        TempDB.Execute "DELETE FROM greedy_ancestors_metrics;"
        MyDB.Execute "INSERT INTO greedy_ancestors_metrics (CUI, ALLDESCENDENTS, ALLCHILDREN) SELECT a.CUI, (h.DNUM + 1) AS ALLDESCENDENTS, COUNT(h.CHILD) AS ALLCHILDREN " _
                   & "FROM greedy_ancestors_x a INNER JOIN " & strScheme & "HIER h ON h.PARENT = a.CUI GROUP BY a.CUI, h.PARENT, h.DNUM;"
        TempDB.Execute "UPDATE greedy_ancestors_x a INNER JOIN greedy_ancestors_metrics m ON m.CUI = a.CUI SET a.ALLDESCENDENTS = m.ALLDESCENDENTS, a.ALLCHILDREN = m.ALLCHILDREN;"
            
        'Don't need to know how many members of the entire exclusion set are direct children of each potential ancestor
        'because we can't have exclusions to the exclusions. So we're not going to consider ANY candidate exclusion groupers that have
        'ANY descendants that are not in the exclusion set

        If CancelCurrentOperation = True Then GoTo GroupCodesInSet_Abort
        
        'Count how many actual members of the exclusion set are subsumed by each potential ancestor
        'No point counting the episodes - it will be zero!
        '(Split into two queries as Access won't do as a single JOIN)
        If DebugOn Then PrintLog ("Counting how many exclusion set members are subsumed by each candidate exclusion ancestor")
        TempDB.Execute "DELETE FROM greedy_int;"
        TempDB.Execute "INSERT INTO greedy_int SELECT a.CUI, COUNT(l.CUI) AS NUM FROM " _
                     & "(greedy_ancestors_x a INNER JOIN greedy_tc_x tc ON a.CUI = tc.SUPERTYPEID) INNER JOIN greedy_list_x l ON l.CUI = tc.SUBTYPEID GROUP BY a.CUI"
        '..and use this to post a TRUEPOS value into the greedy_ancestors_x table
        TempDB.Execute "UPDATE greedy_ancestors_x a1 INNER JOIN greedy_int x ON x.CUI = a1.CUI SET a1.TRUEPOS = x.NUM;"
                                    
        'Count how many members (and episodes) of the enumerated cluster set are subsumed by each potential ancestor
        '(Split into two queries as Access won't do as a single JOIN)
        TempDB.Execute "DELETE FROM greedy_int;"
        TempDB.Execute "INSERT INTO greedy_int SELECT a.CUI, COUNT(l.CUI) AS NUM FROM " _
                     & "(greedy_ancestors_x a INNER JOIN greedy_tc_x tc ON a.CUI = tc.SUPERTYPEID) INNER JOIN greedy_list_f l ON l.CUI = tc.SUBTYPEID GROUP BY a.CUI"
        '..and use this to post a TRUEPOS (CJC:TRUENEG?) value into the greedy_ancestors_x table
        TempDB.Execute "UPDATE greedy_ancestors_x a1 INNER JOIN greedy_int x ON x.CUI = a1.CUI SET a1.TRUENEG = a1.ALLDESCENDENTS - x.NUM;"
        
        'Ignore candidate groupers if the number of true members of the exclusion set subsumed by it is below the threshold
        TempDB.Execute "DELETE FROM greedy_ancestors_x WHERE TRUEPOS < " & MinimumClusterSize & ";"
        'All descendents, but not self, and only one true child (CJC: ? might as well use the child instead??)
        TempDB.Execute "DELETE FROM greedy_ancestors_x WHERE TRUENEG = 1 AND INCLUDE = FALSE AND ALLCHILDREN = 1;"
             
        'Not enough descendents
        TempDB.Execute "DELETE FROM greedy_ancestors_x WHERE (ALLDESCENDENTS - TRUEPOS) > TRUEPOS;"
        
        If DebugOn Then PrintLog ("Discarding redundant candidate exclusion ancestors")
        MyDB.Execute "DELETE a.* FROM (greedy_ancestors_x AS a INNER JOIN " & strScheme & "TC AS tc ON a.CUI = tc.SUBTYPEID) INNER JOIN greedy_ancestors_x AS b ON tc.SUPERTYPEID = b.CUI " _
                   & "WHERE b.CUI <> a.CUI AND a.TRUENEG = 0 AND b.TRUENEG = 0;"
               
        strSQL = "SELECT CUI AS strRES, Include, " & IIf(FrequencyWeighted = True, " FREQ,", "") & " TRUEPOS, ALLDESCENDENTS, SCORE FROM greedy_ancestors_x a WHERE TRUENEG = 0 OR (TRUENEG = 1 AND INCLUDE = FALSE);"
        Set myWinner = TempDB.OpenRecordset(strSQL)
        
        If CancelCurrentOperation = True Then GoTo GroupCodesInSet_Abort
        
        'Accept as a batch all potential exclusion ancestors
        If Not (myWinner.BOF And myWinner.EOF) Then
            If DebugOn Then PrintLog ("START: Exclusion clauses with perfect fit")
            myWinner.MoveFirst
            Do Until myWinner.EOF
                xWinner = myWinner!strRes
                IncludeWinner = myWinner!include
                strWinner = "Found Exclusion #" & ClauseNumber & " "
                strWinner = strWinner & IIf(IncludeWinner = True, "<<", " <") & DisplayCode(xWinner, strScheme, , , True)
                strWinner = strWinner & " (" & myWinner!TRUEPOS & " of " & myWinner!ALLDESCENDENTS & " descendant" & IIf(myWinner!ALLDESCENDENTS = 1, "", "s") & " require exclusion)"
                If DebugOn Then PrintLog strWinner

                'Post the winner into the output table
                'Greedy Output : CLUSTERID CLAUSENUM SCORE INCLUDE EXTENSION CUI DESCENDENTS TRUEPOS TRUENEG ZOOM LISTSIZE
                 MyDB.Execute "INSERT INTO QUERY_REFACTORED SELECT DISTINCT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, SCORE AS SCORE, FALSE AS INCLUDE, " _
                            & IIf(IncludeWinner = True, "'<<'", "'<'") & " AS EXTENSION, '" & xWinner & "' AS CUI, ALLDESCENDENTS AS DESCENDENTS, TRUEPOS AS TRUEPOS, TRUENEG AS TRUENEG, " _
                            & xZoom & " AS ZOOM, " & xListSize & " AS LISTSIZE FROM greedy_ancestors_x a WHERE a.CUI = '" & xWinner & "';"
                ClauseNumber = ClauseNumber + 1
                ClauseCount = ClauseCount + 1
                myWinner.MoveNext
            Loop
            'Remove the winners from the set of ancestors to be considered in subsequent iterations
            TempDB.Execute "DELETE * FROM greedy_ancestors_x WHERE TRUENEG = 0 OR (TRUENEG = 1 AND INCLUDE = FALSE);"
            'Remove all codes covered by the new clauses from the code set to be considered in subsequent iterations
            MyDB.Execute "DELETE l.* FROM greedy_list_x l INNER JOIN (Query_Refactored i INNER JOIN greedy_tc_x tc ON i.CUI = tc.SUPERTYPEID) ON tc.SUBTYPEID = l.CUI WHERE i.INCLUDE = FALSE;"
            If DebugOn Then PrintLog ("DONE: Exclusion clauses with perfect fit")
        End If
        
        'Residue of the exclusion set is added as a flat list of exclusions
        'Leaf node concepts (ie that currently have no descendants) are added with an << extension
        'in case they acquire descendants in the future (this also facillitates range building)
        'Greedy Output : CLUSTERID CLAUSENUM  SCORE  INCLUDE  EXTENSION  CUI DESCENDENTS TRUEPOS TRUENEG ZOOM LISTSIZE
        MyDB.Execute "INSERT INTO QUERY_REFACTORED SELECT DISTINCT '" & ClusterID & "' AS ID, " & ClauseNumber & " AS CLAUSENUM, 0 AS SCORE, FALSE AS INCLUDE, " _
                   & "IIF(ISNULL(h.PARENT),'<<','=') AS EXTENSION,x.CUI AS CUI,0 AS DESCENDENTS,0 AS TRUEPOS,0 AS TRUENEG," & Zoom & " AS ZOOM, " & ListSize & " AS LISTSIZE " _
                   & "FROM greedy_list_x AS x LEFT JOIN " & strScheme & "HIER AS h ON x.CUI = h.PARENT;"
        If DebugOn Then PrintLog ("  ungroupable residue of " & MyDB.RecordsAffected & " added as individual exclusion clauses")
        
        If DebugOn Then PrintLog ("DONE: FINDING EXCLUSION CLAUSES")
    Else
        If DebugOn Then PrintLog ("No exclusion clauses needed")
    End If
    
    Residue = SQLCount("SELECT COUNT(CUI) AS RES FROM QUERY_REFACTORED;")
    PrintLog Residue & " raw clause" & IIf(Residue = 1, "", "s") & " produced by refactoring analysis"
    If CancelCurrentOperation = True Then GoTo GroupCodesInSet_Abort
    
    'Final clear up:
        'Merge sticky < and = on same concept to a single sticky <<
        MyDB.Execute "UPDATE QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON (a.CUI = b.CUI AND a.INCLUDE = b.INCLUDE AND a.EXTENSION = '=' AND b.EXTENSION = '<') SET a.EXTENSION = '<<' WHERE a.STICKY = b.STICKY;"
        Residue = MyDB.RecordsAffected
        If DebugOn And Residue > 0 Then PrintLog Residue & " < and = clause" & IIf(Residue = 1, "", "s") & " merged"
        ' Discard any sticky INclusion clauses that are matched by an exactly corresponding sticky EXclusion clause
        MyDB.Execute "DELETE a.* FROM QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON (a.CUI = b.CUI) WHERE a.STICKY = TRUE AND b.STICKY = TRUE AND a.INCLUDE = TRUE AND b.INCLUDE = FALSE AND a.EXTENSION = '=' AND b.EXTENSION IN ('=','<<');"
        Residue = MyDB.RecordsAffected
        MyDB.Execute "DELETE a.* FROM QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON (a.CUI = b.CUI) WHERE a.STICKY = TRUE AND b.STICKY = TRUE AND a.INCLUDE = TRUE AND b.INCLUDE = FALSE AND a.EXTENSION = '<' AND b.EXTENSION IN ('<','<<');"
        Residue = Residue + MyDB.RecordsAffected
        MyDB.Execute "DELETE a.* FROM QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON (a.CUI = b.CUI) WHERE a.STICKY = TRUE AND b.STICKY = TRUE AND a.INCLUDE = TRUE AND b.INCLUDE = FALSE AND a.EXTENSION = '<<' AND b.EXTENSION = '<<';"
        Residue = Residue + MyDB.RecordsAffected
        If DebugOn And Residue > 0 Then PrintLog Residue & " sticky inclusion clauses" & IIf(Residue = 1, "", "s") & " pruned where exactly matching sticky exclusion clause"
        
        'remove duplicate clauses
        MyDB.Execute "DELETE a.* FROM QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON (a.CUI = b.CUI AND a.INCLUDE = b.INCLUDE AND a.EXTENSION = b.EXTENSION) WHERE (a.CLAUSENUM < b.CLAUSENUM AND a.STICKY = FALSE) OR (a.CLAUSENUM > b.CLAUSENUM AND b.STICKY = TRUE);"
        Residue = MyDB.RecordsAffected
        If DebugOn And Residue > 0 Then PrintLog Residue & " duplicate clause" & IIf(Residue = 1, "", "s") & " pruned"
        'remove < clauses on a concept if a << clause exists on the same concept
        'includes removing a sticky < that is made redundant by a sticky <<
        MyDB.Execute "DELETE a.* FROM QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON (a.CUI = b.CUI AND a.INCLUDE = b.INCLUDE) WHERE a.EXTENSION = '<' AND b.EXTENSION = '<<' AND (a.STICKY = FALSE OR (a.STICKY = TRUE AND b.STICKY = TRUE));"
        Residue = MyDB.RecordsAffected
        'remove clauses that are subsumed by another clause with << or < extension
        'includes removing a sticky clause that is made redundant by another sticky clause
        MyDB.Execute "DELETE a.* FROM (QUERY_REFACTORED AS a INNER JOIN " & strScheme & "TC AS tc ON a.CUI = tc.SUBTYPEID) INNER JOIN QUERY_REFACTORED AS b ON tc.SUPERTYPEID = b.CUI " _
                   & "WHERE b.EXTENSION IN ('<','<<') AND b.CUI <> a.CUI AND a.INCLUDE = b.INCLUDE AND (a.STICKY = FALSE OR (a.STICKY = TRUE AND b.STICKY = TRUE));"
        Residue = Residue + MyDB.RecordsAffected
        'remove any = clause made redundant by a << on the same concept
        'includes removing a sticky = made redundant by a sticky <<
        MyDB.Execute "DELETE a.* FROM QUERY_REFACTORED AS a INNER JOIN QUERY_REFACTORED AS b ON (a.CUI = b.CUI AND a.INCLUDE = b.INCLUDE) WHERE a.EXTENSION = '=' AND b.EXTENSION = '<<' AND a.STICKY = b.STICKY;"
        Residue = Residue + MyDB.RecordsAffected
        If DebugOn And Residue > 0 Then PrintLog Residue & " redundant clause" & IIf(Residue = 1, "", "s") & " pruned"
        'Modify or remove clauses involving concepts from the global exclusion list
        If ApplyFilters = True And strScheme = "SCT" Then
            MyDB.Execute "DELETE a.* FROM (QUERY_REFACTORED AS a INNER JOIN SCT AS s ON s.CUI = a.CUI) WHERE s.TYP = 1 AND s.F4 = TRUE AND a.EXTENSION = '=' AND a.STICKY = FALSE;"
            Residue = MyDB.RecordsAffected
            If DebugOn And Residue > 0 Then PrintLog Residue & " 'concept only' clause" & IIf(Residue = 1, "", "s") & " pruned because concept is in global exclusion list"
            MyDB.Execute "UPDATE QUERY_REFACTORED AS a INNER JOIN SCT AS s ON s.CUI = a.CUI SET a.EXTENSION = '<' WHERE s.TYP = 1 AND s.F4 = TRUE AND a.EXTENSION = '<<' AND a.INCLUDE = TRUE AND a.STICKY = FALSE;"
            Residue = MyDB.RecordsAffected
            If DebugOn And Residue > 0 Then PrintLog Residue & " 'concept and descendents' clause" & IIf(Residue = 1, "", "s") & " converted to 'descendents only' because concept is in global exclusion list"
        End If
    
    Residue = SQLCount("SELECT COUNT(CUI) AS RES FROM QUERY_REFACTORED;")
    PrintLog Residue & " clause" & IIf(Residue = 1, " survives", "s survive") & " after final prune and tidy up"
               
    LogLevel = IIf(LogLevel > 0, LogLevel - 1, 0)
    If Residue > 0 Then
        GroupCodesInSet = RenderEnumeratedCluster(strScheme, "CUI", "QUERY_REFACTORED", "CG", "ID", ClusterID)
        'GroupCodesInSet = RenderCluster(strScheme, "CUI", "QUERY_REFACTORED", "QOF-R", "ID", ClusterID)
    Else
        GroupCodesInSet = "WARNING: no clauses in refactored cluster"
    End If
    
    If Left(GroupCodesInSet, 5) = "ERROR" Then
        PrintLog GroupCodesInSet
        GroupCodesInSet = ""
    Else
        PrintLog ("RESULT : " & GroupCodesInSet)
    End If
            
    PrintLog ("DONE: REFACTORING " & strScheme & " encoding of " & ClusterID)
    If DoProgress Then Call ShowProgress(10, 10, , "CLEAR")
       
GroupCodesInSet_Abort:

    If CancelCurrentOperation = True Then GroupCodesInSet = "WARNING: Refactoring cancelled by user"
    
    ' Clear up
    On Error Resume Next
    TempDB.Close
    myWinner.Close
    
    MyDB.TableDefs.Delete "greedy_ancestors"
    MyDB.TableDefs.Delete "greedy_list"
    MyDB.TableDefs.Delete "greedy_exclusion_list"
    MyDB.TableDefs.Delete "greedy_vals"
    MyDB.TableDefs.Delete "greedy_vals_x"
    MyDB.TableDefs.Delete "greedy_ancestors_x"
    MyDB.TableDefs.Delete "greedy_ancestors_metrics"
    MyDB.TableDefs.Delete "greedy_list_x"
    MyDB.TableDefs.Delete "greedy_list_f"
    MyDB.TableDefs.Delete "greedy_tc"
    MyDB.TableDefs.Delete "greedy_tc_x"
    MyDB.TableDefs.Delete "greedy_temp"
    MyDB.TableDefs.Delete "query_refactored"

    DoCmd.Hourglass False
    If Not KillFile(tPath, "Temp.mdb") Then PrintLog ("WARNING: Could not clear up working tables after REFACTOR")
    LogLevel = initLogLevel
    Exit Function
    
GroupCodesInSet_Error:
    DoCmd.Hourglass False
    Select Case Err.Number
        Case 3061
            PrintLog ("ERROR: SYNTAX ERROR in REFACTOR call (probably!)")
            Call Refactor("/?", " ")
        Case Else
            PrintLog ("ERROR: " & Err.Number & " " & Err.Description & " in Tes.GroupCodesInSet")
    End Select
    GroupCodesInSet = ""
    LogLevel = initLogLevel
End Function